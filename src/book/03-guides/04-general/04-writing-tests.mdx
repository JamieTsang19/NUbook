---
section: Guides
chapter: Tools
title: How to Write Tests
description: General Information About Making Tests
slug: /guides/tools/catch-tests
---

This guide presents some general information about unit testing and tests in general.

## What is a Unit Test?

A unit test is a test of a small piece of a codebase - a unit. Unit tests are meant to test only that piece of code and they serve to validate its correctness. This contrasts with integration tests, which tests the interactions of pieces of code and their behaviour together. For the rest of this guide, we'll work with the following toy utility function 

```cpp
[[nodiscard]] inline int add(const int a, const int b) noexcept {
    return a + b;
}
```

## Anatomy of a Unit Test

The basic pieces you will need to create a unit test for a function are the following:

1. A set of inputs for the function. These should match the input parameters. In our case, we'll need a set of pairs of integers.
2. The associated outputs which you want for each input. These are often referred to as the "ground truth", because they are the true values your function should output. For our `add` example with the pair of inputs (2, 2), we want the output 4, because `add(2, 2) == 4`.

The process of running the tests is as simple as calling the function with your inputs and verifying that the function's output was as expected. In our example, one of the test cases could be running `add(2, 2)` and checking that the result is 4.

## Testing Approach and Philosophy

There are many guidelines you can find online to help you to write good tests. Here are a few:

- Tests should be simple and readable enough to be correct on inspection. You don't want to think about whether a test is correct or not. Ideally you'll be able to read it and know that it's legitimate.
- Make test cases independent. The outcome of one test case shouldn't affect the outcome of others.
- Demonstrate how a piece of code should be used with its tests. We can't google for examples of people using our software, so create examples with your tests.
- Tests should be deterministic - [seed your randomness](https://en.wikipedia.org/wiki/Random_seed). If you're testing something particularly reliant on randomness or which generates randomness, compensate by using a variety of seeds with many cases each.
- Follow the **AAA** structure: Arrange, Act, Assert. Each test should follow the general design of first setting up your input variables (Arrange), calling your unit with those variables (Act), then finally checking your outputs match what they should (Assert).

### General Approach

Write the easy tests first, then think about edge cases and code coverage. For `add`, you might make the `(2, 2) == 4` case first, then `(123000, 456) == 123456`. After you have some simple cases, you could consider throwing in some zeros and negative numbers - cases where the observed behaviour is different somehow. 

Later, you might consider what should happen on integer overflow/wraparound, making sure that errors are handled correctly. At that stage you could also try to make a test case covering every possible branch of your code. The amount of code you execute in a set of tests is referred to as the "code coverage" of the tests.

### Regression Tests

When we find bugs in the codebase and fix them, we should add a test case which makes sure that that code doesn't _regress_ into the buggy behaviour. This test case is called a regression test. Regression tests should be labelled with comments to indicate the behaviour they're watching for. If there is a GitHub  The regression test should be written such that it would fail before the fix, and pass after the fix.

For a concrete example, imagine that a bug was found with `add` where when both inputs were negative, it always returned 0. Good practice would be to add a test case or small set of test cases where both inputs were negative, labelling them as regression tests for that bug.

### Black Box vs White Box Testing

When we write tests, we can make them completely ignorant to the internals of the code. Such a test worries only about the inputs and outputs, considering the parts in the middle as a black box which we can't see inside - black box testing.

White box testing looks at the internals and makes tests which depend on them. This means that any significant change to the implementation of a function which doesn't change its interface is likely to break white box tests which depended on the old function. The fragility of white box tests to change is the chief reason that black box tests are preferred.

Ideally, you're able to write tests as you design your software interfaces, writing the code afterwards such that it fulfills the needs of the tests. This is the basis of [**Test-Driven Development**](https://en.wikipedia.org/wiki/Test-driven_development), which is a powerful means of creating high quality software.


